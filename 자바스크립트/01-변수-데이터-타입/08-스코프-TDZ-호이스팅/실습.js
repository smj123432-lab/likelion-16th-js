// --------------------------------------------------------------------------
// 함수 요약
// --------------------------------------------------------------------------
// * 함수 선언(정의)
// * 함수 호출(사용, 실행)
// * 함수 반환(결과 값)
// * 함수 확장(매개변수, 인자)
// * 함수 종료(중단)
// * 함수 표현식: 변수 = 함수(값)
// --------------------------------------------------------------------------

// 함수 정의
// 1. 함수 선언문
function logger(nth, fightingMessage) {
  // 함수 안에 지역변수 선언
  let resultLog = '멋사 프론트엔드 부트캠프'
  const numberNth = parseInt(nth, 10)

  // 특정 상황(조건)이 확인되면 함수를 여기서 종료하겠다.
  // return resultLog + ' ' + numberNth + '기 여러분! 중도 이탈은 안되요!! 💦'
  // 종료 이후엔 코드 실행이 안됨

  // 암묵적으로 undefined 반환
  // return

  // 명시적으로 결과 값 반환
  return resultLog + ' ' + numberNth + '기 ' + fightingMessage
}

// 함수 실행(사용, 호출)
console.log(logger('16기', '여러분 힘내세요! 💪'))
console.log(logger(14, '멋진 개발자되세요! 😊'))
console.log(logger(12, '월급 많이 받으세요~ 🍀'))


// 2. 함수 표현식
// const 변수 = 함수(값)
const myLogger = function(nth, message) {
  let resultMessage = ''
  resultMessage += '멋사 ' + parseInt(nth, 10) + '기 여러분!'
  resultMessage += ' '
  resultMessage += message
  resultMessage += '🥳'

  return resultMessage
}

console.log(myLogger(16, '오늘도 행복하세요!'))

function 표_만들기(표_제목) {
  // const 표_마크업 = '<table><caption>' + 표_제목 + '</caption><tr><th scope="col">셀 제목 1</th><th scope="col">셀 제목 2</th></tr><tbody><tr><td>셀 내용 1</td><td>셀 내용 2</td></tr></tbody></table>'
  
  let 표_마크업 = ''
  표_마크업 += '<table>'
  표_마크업 += '  <caption>' + 표_제목 + '</caption>'
  표_마크업 += '  <tr>'
  표_마크업 += '    <th scope="col">셀 제목 1</th>'
  표_마크업 += '    <th scope="col">셀 제목 2</th>'
  표_마크업 += '  </tr>'
  표_마크업 += '  <tbody>'
  표_마크업 += '    <tr>'
  표_마크업 += '      <td>셀 내용 1</td>'
  표_마크업 += '      <td>셀 내용 2</td>'
  표_마크업 += '    </tr>'
  표_마크업 += '  </tbody>'
  표_마크업 += '</table>'

  return 표_마크업
}

console.log(표_만들기('JavaScript로 마크업하기!'))
console.log(표_만들기('HTML로 마크업하기!'))

// --------------------------------------------------------------------------
// 실습: 변수의 범위와 안전 수칙 (Scope & TDZ)
// --------------------------------------------------------------------------
// * 스코프(Scope) : 변수가 어디까지 유효한지 결정하는 범위입니다.
// * 일시적 사각지대(TDZ) : 변수 선언 후, 초기화 전까지 접근 불가능한 구간입니다.
// * 호이스팅(Hoisting) : 선언문이 코드 최상단으로 끌어올려진 것처럼 작동하는 현상입니다.
// --------------------------------------------------------------------------


// --------------------------------------------------------------------------
// 스코프 (Scope) - 전역과 지역
// --------------------------------------------------------------------------

// 전역 변수 garden 선언 ('마당의 꽃')

// 블록(block, { ... }) - 지역 생성
// { 
//   // 블록 내부에서만 사용 가능한 지역 변수
//   // var는 로컬 글로벌 구분이 없음

//   const blockVariable = '블록 내부의 변수'
//   console.log(blockVariable);
// }

// console.log(blockVariable);
// -------------------------------------------------
// 함수 myHouse 선언
let garden= '마당의 꽃' 
// function myHouse() {

  // - 지역 변수 desk 선언 ('책상 위의 노트북')
  // const desk = '책상 위의 노트북'
  // - 전역 변수 garden, 지역 변수 desk 콘솔에 출력
//   console.log('garden: ', garden) ['garden: ','마당의 꽃' ];
//   console.log('desk: ', desk) ['desk: ','책상 위의 노트북' ];
// }
// myHouse()


// 전역에서 garden, desk 변수 값 콘솔에 출력
// - 함수 내부(지역)에서는 외부(전역) 변수에 접근할 수 있습니다.
// - 외부(전역)에서는 함수 내부(지역) 변수에 접근할 수 없습니다. (ReferenceError)

// garden 출력 결과
// console.log(garden);
// desk 출력 결과
// console.log(desk);

// --------------------------------------------------------------------------
// 스코프 체인 (Scope Chain)
// --------------------------------------------------------------------------

// 함수 outer 선언
const outer = function () {  
  // - 지역 변수 livingRoom 선언 ('거실의 소파')
  const livingRoom = '거실의 소리'
  // - 내부 함수 inner 선언
  const inner = function () {
    //   - 지역 변수 myRoom 선언 ('내 방의 침대')
    const myRoom = '내 방의 침대'
    //   - 전역 변수 garden, 상위 함수 변수 livingRoom, 지역 변수 myRoom 출력
  console.log(garden);
  console.log(livingRoom);
  console.log(myRoom);
  }
  // - 내부 함수 inner 호출
  inner()
  console.log(garden);
  console.log(livingRoom);
  console.log(myRoom);

}
  // 함수 outer 호출
outer()
// 설명: 변수를 찾을 때 현재 범위에 없으면, 점점 더 바깥 범위로 나가며 찾습니다.
// 출력 결과:
// - 전역 변수: '마당의 꽃'
// - outer 함수 내부 지역 변수: '거실의 소파'
// - inner 함수 내부 지역 변수: '내 방의 침대'


// --------------------------------------------------------------------------
// 호이스팅 (Hoisting) - 함수 선언문
// --------------------------------------------------------------------------

// 함수 선언보다 호출을 먼저 작성 (sayHello)

// 함수 sayHello 선언 ('안녕! JavaScript 🌼' 출력)
function sayHello() {
  return '안녕! 자바스크립트'
}
console.log(sayHello())
// 설명: 함수 선언문은 코드 맨 위로 끌어올려지므로, 
//      선언 전에도 호출이 가능하도록 작동합니다.
// 출력 결과: '안녕! JavaScript 🌼'


// --------------------------------------------------------------------------
// 호이스팅과 TDZ - var vs let/const
// --------------------------------------------------------------------------

// 1. var의 경우 (위험)
// 변수 선언 전 tempVar 출력
// 변수 tempVar를 var로 선언 및 초기화 ('나는 var')

// 2. let/const의 경우 (안전)
// 변수 선언 전 tempLet 출력 (ReferenceError 발생)
// 변수 tempLet을 let으로 선언 및 초기화 ('나는 let')

// 설명:
// var는 호이스팅 시, undefined로 초기화되어 미리 접근이 가능하도록 작동합니다. (버그 원인)
// let/const는 호이스팅되지만, 초기화 전까지 TDZ(접근 금지 구역)에 갇혀 에러를 발생시킵니다.
// 출력 결과: undefined


// --------------------------------------------------------------------------
// 함수 표현식과 호이스팅
// --------------------------------------------------------------------------

// 함수 표현식 선언 전, sayBye 호출 (ReferenceError 발생)

// const 키워드를 사용해 sayBye 변수에 함수 표현식 할당 ('잘 가! JavaScript 👋' 출력)
console.log(sayBye);
const sayBye = function () {
  return '가라! JavaScript'
}
console.log(sayBye());
// 함수 표현식 선언 후 sayBye 호출

// 설명:
// 함수 표현식은 '변수 호이스팅' 규칙을 따릅니다.
// const로 선언되었으므로 TDZ의 영향을 받아, 선언 라인 전에는 사용할 수 없게 작동합니다.
// 출력 결과: '잘 가! JavaScript 👋'


// --------------------------------------------------------------------------
// 핵심!
// --------------------------------------------------------------------------
// 1. 안쪽 스코프에서는 바깥쪽을 볼 수 있지만, 바깥쪽에서는 안쪽을 볼 수 없습니다.
// 2. 호이스팅은 선언을 최상단으로 끌어올린 것처럼 작동하는 현상입니다. (함수 선언문은 즉시 사용 가능)
// 3. let과 const는 TDZ(일시적 사각지대) 덕분에 선언 전에 사용하는 실수를 막아줍니다.